## 14장 전역 변수의 문제점

지역 변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.

그리고 언젠가 소멸한다. 즉,변수는 생물과 유사하게 생성되고 소멸되는 생명 주기가 있다.

변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.

변수는 자신이 선언된 위치에서 생성되고 소멸한다.

전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다. 하지만 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.

지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

---

## 16장 프로퍼티 어트리뷰트

접근자 함수는 getter/setter 함수 라고도 부른다.

접근자 프로퍼티는 getter/setter 함수를 모두 정의 할 수 있도 있고 하나만 정의 할 수도 있다.

---

## 17장 생성자 함수

#### 생성자 함수는

이름 그대로 객체(인스턴스)를 생성하는 함수다.

하지만 자바와 같은 클래스 기반 객체지향언어의 생성자와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.

만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반함수로 동작한다.

생성자 함수의 역할은

프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다.

생성자 함수가 인스턴스를 생성하는 것은 필수 이고,생성된 인스턴스를 초기화하는 것은 옵션이다.

#### ???바인딩

바인딩이란 식별자와 값을 연결하는 과정을 의미한다.

예를 들어,변수 선언은 변수 이름 (식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다.

this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다.)와 this가 가리킬 객체를 바인딩하는 것이다.

##### new.target

new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다.

new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.

생성자 함수가 new 연산자 없이 호출 되는것을 방지하기 위해 ES6에서는 new.target문법을 지원한다.

new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다.

new.target은 new연산자를 사용했는지 여부를 감지하는 것인데요.

인스턴스화된 생성자와 함수에서 new.target은 생성자 or 함수참조를 반환합니다.

따라서 함수 내부에서 new.target을 사용하여 생성자 함수로서 호출됐는지 확인하여 그렇지 않은 경우 new 연산자와 함께 재귀 호출을 통해 생성자 함수로서 호출할 수 있다.

---
