## 10장 객체리터럴

-프로퍼티:객체의 상태를 나타내는 값

-메서드:프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

#### 인스턴스란

클래스에 의해 생성되어 메모리에 저장된 실체를 말한다.
객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다.
클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다.
인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어이다.

#### 리터럴은

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말한다.
객체 리터럴은 객체를 생성하기 위한 표기법이다.
객체 리터럴은 중괄호({})내에 0개 이상의 프로퍼티를 정의한다.

#### ??메서드

자바스크립트에서 사용할 수 잇는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다.
아직 살펴보지 않았지만 자바스크립트의 함수는 객체(일급객체)다. 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.
프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드 라 부른다.
즉 메서드는 객체에 묶여있는 함수를 의미한다.

---

## 11장 원시 값과 객체의 비교

#### 원시값은

변경 불가능한 값이다.
한번 생성된 원시 값은 읽기 전용 값으로서 변경할 수 없다.
값을 변경할 수 없다는 것이 구체적으로 무엇을 말하는지 생각해보자. 먼저 변수와 값은 구분해서 생각해야 한다.변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고 , 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말한다.
변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.
즉,원시 값은 변경 불가능하다 는 말은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 변수는 언제든지 재할당을 통해 변수 값을 변경(엄밀히 말하자면 교체)할 수 있다.그렇기 때문에 변수라고 부른다.

#### ?? 유사 배역 객체

유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수 도 있다.
원시 값을 객체처러 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다.

#### 🔴변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다.

이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

얕은 복사 ( 1단계만 복사 )↔ 깊은 복사 (재귀적으로 원시값까지 전부 복사)
얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다.
즉,원본과 본사본은 참조 값이 다른 별개의 객체다.
하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.
참고로 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사,객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.

결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.

다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달 ”만이 존재한다고 말할 수 있다.

---

## 12장 함수

함수 선언문은 표현식이 아닌 문이다.

#### 변수 선언의 실행 시점 과 변수 호이스팅

변수 할당문의 값은 할당문이 실행되는 시점,즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

#### 화살표 함수

기존 함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

#### 재귀함수

자기자신을 여러번 호출 하는 함수

#### 콜백함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수 라고 하며,매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.
매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차 함수라 한다.
콜백 함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.
단,중첩함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체 할 수 있다는 장점이 있다. 즉 ,고차 함수는 콜백 함수를 자신의 일부분으로 함성한다.
고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
콜백 함수는 고차함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

---

## 23장 실행 컨텍스트

## 소스코드의 타입

- 전역 코드 : 전역에 존재하는 소스코드를 말한다. 전역에 정의된 함수.클래스 등의 내부 코드는 포함되지 않는다.
- 함수 코드 : 함수 내부에 존재하는 소스코드를 말한다. 함수 내부에 중첩된 함수 . 클래스 등의 내부 코드는 포함되지 않는다.
- eval 코드 : 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드를 말한다.
- 모듈 코드 : 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.

코드가 실행되려면 다음과 같이 스코프,식별자,코드 실행 순서 등의 관리가 필요하다.
실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
실행 컨텍스트는 식별자(변수,함수,클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로,모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.

---

## 13장 스코프

#### 렉시컬 환경/static scope 정적스코프 ,어휘적 스코프

-어디서 정의했느냐가 중요함 -스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.

#### ↔dynamic scope 동적 스코프

-어디서 호출했는지에 따라 상위 스코프가 달라짐 -자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.

함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.
즉,함수의 상위 스코프는 언제나 자신이 정의된 스코프다.
이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다.
함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다.
함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다 .
