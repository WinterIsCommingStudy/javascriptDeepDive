#4장 변수 

##메모리는
데이터를 저장할  수 있는 메모리 셀 의 집합체이다. 
메모리 셀 하나의 크기는 1바이트(8비트) 이며, 컴퓨터는 메모리 셀의 크기 즉 1바이트 단위로 데이터를 저장 하거나 읽어 들인다.
각 셀은 고유의 메모리 주소를 갖는다.

##변수는 
하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 
변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 
따라서 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값을 접근할 수 있다. 
변수이름을 식별자 라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

##식별자는
- 값이 저장되어 잇는 메모리 주소와 매핑 관계를 맺으며, 이매핑 정보도 메모리에 저장 되어야한다.
- 값이 아니라 메모리 주소를 기억 하고 있다.
- 메모리 주소에 붙인 이음이라고 할 수 있다.

##변수선언
자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다. 
- 선언단계:변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로  undefined를 할당해 초기화한다.

##?!변수의 이름은 어디에 등록 되는가?
변수이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 
실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역이다. 
자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리 한다.
변수 이름과 변수 값은 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리 된다.

##초기화란
변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. 
만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 남아 있을 수 있다.
이러한 값을 쓰레기 값이라 한다. 따라서 메모리 공간을 확보한 다음.
값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다.

##?! 변수를 사용하려면 반드시 선언이 필요하다. 
변수뿐만 아니라 모든 식별자(함수,클래스)가 그렇다. 
만약 선언하지 않은 식별자에 접근하면 Reference Error(참조 에러)가 발생 한다. 
Reference Error는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를  찾을 수 없을 때 발생하는 에러다.

##호이스팅
변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다. 
(변수 선언(선언단계와 초기화단계)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행)
🔴변수 선언뿐 아니라 var,let,const,function,function*,class키워드를 사용해서 선언하는 모든 식별자(변수,함수,클래스 등)는 호이스팅 된다. 
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

####값의 재할당
변수에 값을 재할당하면 변수의 값은 이전 값에서 재할당한 값으로 변경된다. 
처음 값을 할당했을 때와 마찬가지로 이전값이 저장되어 있던 메모리 공간을 지우고
그 메모리 공간에 재할당 값을 새롭게 저장하는 것이 아니라 
새로운 메모리 공간을 확보하고 그 메모리 공간에 재할당 값을 저장한다.


###?! 가비지 콜렉터
어떤 식별자와도 연결되어 있지 않은 값 →불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제 된다.
단, 메모리에서 언제 해제 될지는 예측할 수 없다. 
가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제 하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 
자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.

###?! 언매니지드 언어 와 매니지드 언어 
프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지드 언어로 분류할 수 있다. 
    C언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc() 과 free() 같은 저수준 메모리 제어 기능을 제공한다. 
언매니지드 언어는 메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 그 반대의 경우 치명적 오류를 생산할 가능성도 있다. 
   자바스크립트 같은 매니지드 언어는 매모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다. 
즉,개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 
더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며,이 또한 개발자가 관여할 수 없다. 
매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느 정도 일정한 생산성을 확보 할 수 있다는 장점이 있지만 성능 면에서 어느 정도의 손실을 감수할 수 밖에 없다.


--------------------------------------------------------------------------------------------
#5장 값
모든 값은 데이터 타입을 가지며,메모리에 2진수,즉 비트의 나열로 저장된다. 

메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될수 있다.

##리터럴은 
- 사람이 이해할 수 잇는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
- 사람이 이해할 수 있는 문자(아라비아 숫자,알파벳,한글 등 ) 또는
       미리 약속된 기호 (’’,””,.,[],{},//등)로 표기한 코드다.
자바스크립트 엔진은 코드가 실행되는 시점인 런타임 에 리터럴을 평가해 값을 생성한다. 
즉,리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.


##표현식은
값으로 평가될 수 있는 문 이다. 
즉,표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조 한다. 
앞서 살펴본 리터럴은 값으로 평가된다. 따라서 리터럴도 표현식이다. 
-값으로 평가될 수 있는 문은 모두 표현식이다.


##문 은
프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 
문은 여러 토큰으로 구성된다. 
토큰이란 문법적인 의미를 가지며,문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다. 
예를 들어 , 키워드,식별자,연산자,리터럴,세미콜론(;)이나 마침표(.) 등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 이므로 모두 토큰이다.
문을 명령문이라고도 부른다. 즉, 문은 컴퓨터에 내리는 명령이다. 
문은 선언문,할당문,조건문,반복문 등으로 구분할 수 있다.


##표현식과 문을 구별하는 방법
표현식인 문은 값으로 평가될 수 있는 문이며,
표현식이 아닌 문은 값으로 평가될 없는 문을 말한다.
예를 들어, 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다.
하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문 이다.

// 변수 선언문은 표현식이 아닌 문이다. 
var x;
// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다.즉, 할당문은 표현식인 문이다.
x=100;

---------------------------------------------------------------------------------------------------------------
#6장 데이터 타입

##테이터 타입은

값의 종류를 말한다.
자바스크립트(ES6)는 7개의 데이터 타입을 제공한다.
7개의 데이터 타입은 원시 타입과 객체타입으로 분류할 수 있다.

ㅁ원시 타입
-숫자 타입
-문자열 타입
-불리언 타입
-undefined 타입
-null 타입
-심벌 타입

ㅁ객체 타입
-객체,함수,배열 등

숫자타입의 값 1 과 문자열 타입의 값 ‘1’은 비슷해 보이지만 전혀 다른 값이다. 
숫자타입의 값은 주로 산술 연산을 위해 생성하고
문자열 타입의 값은 주로 텍스트를 화면에 출력하기 위해 생성한다. 
또한 확보해야 할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 일어 들여 해석하는 방식도 다르다.


##숫자타입
자바스크립트는 독특하게 하나의 숫자타입만 존재 한다. 
ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.
즉,모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다. 
정수,실수,2진수,8진수,16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.
자바스크립트는 2진수,8진수,16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석 된다.


##문자열 타입은
텍스트 데이터를 나타내는 데 사용한다. 
문자열은 0개 이상의 16비트 유니코드 문자 (UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 잇다. 
 다른 타입과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서 이다. 
자바스크립트의 문자열은 원시 타입이며,변경 불가능한 값이다. 
이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.

##심벌타입은 
ES6에서 추가된 7번째 타입으로 ,변경 불가능한 원시 타입의 값이다.
심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 
따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다. 
심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해 생성한다. 
이때 생성된 심벌 값은 외부에 노출되지 않으며,다른 값과 절대 중복되지 않는 유일무이한 값이다.

###테이터 타입의 필요성
- 데이터 타입에 의한 메모리 공간의 확보와 참조
값은 메모리에 저장하고 참조할 수 있어야 한다. 
메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야한다. 
몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.

-----------------------------------------------------------------------------------------------------------------------
#7장 연산자
일치 비교 연산자에서 주의 할것은 NaN이다. 
NaN은 자신과 일치하지 않는 유일한 값이다. 
따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다. 

ex)Number.isNaN(NaN)→true,Object.is(NaN,NaN)→true

[Object.is] 메서드 
앞에서 살펴본 바와 같이 동등 비교 연산자(==)와 일치 비교 연사자(===)는 
+0과 -0을 동일하다고 평가한다. 
또한 동일한 값인 NaN과 NaN을 비교하면 다른 값이라고 평가한다. 
ES6에서 도입된 [Object.is] 메서드는 다음과 같이 예측 가능한 비교 결과를 반환한다. 
그 외에는 일치 비교 연산자(===)와 동일하게 동작한다.

##삼항 조건 연산자 
if ….else 문은 표현식이 아닌 문이기 때문에 if….else 문은 값처럼 사용할 수 없다. 
ex)
var x =10;

var result = if (x%2){result = ‘홀수’}else {result = ‘짝수’};

//SyntaxError: Unexpected token if



##논리 연산자

####드 모르간의 법칙 

논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있다. 
이러한 경우 드 모르간 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환 할 수 있다.

------------------------------------------------------------------------------------------------------
#8장 제어문

##반복문 
do…while 문 
do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 
따라서 코드 블록은 무조건 한 번 이상 실행된다.


--------------------------------------------------------------------------------------------------------
#9장 타입변환과 단축 평가

##타입변환 이란 ?
값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 
개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅 이라한다. 
개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환 또는 타입 강제 변환 이라 한다.

##??함수 매개변수에 기본값을 설정 할 때 
함수를 호출할 때 인수를 전달하지 않으면 매개변수에는  undefined가 할당된다. 
이때 단축 평가를 사용해 매개변수의 기본값을 설정하면 undefined로 인해 발행할 수 있는 에러를 방지 할 수 있다.

##??옵셔널 체이닝 연산자 ??
옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null또는 undefined인 경우 undefined 를 반환하고 , 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. 

##??null 병합 연산자??
null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
 null 병합 연산자 ??는 변수에 기본값을 설정할 때 유용하다.



