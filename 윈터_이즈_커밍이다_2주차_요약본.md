# ◈ 강민희
| 발표 날짜  |                   발표 주제                    |
| :--------: | :--------------------------------------------: |
| 2022-11-16 |    [얕은 복사와 깊은 복사에 대해](./1-1.md)    |
| 2022-11-20 |   [new Function은 언제 사용할까?](./1-2.md)    |
| 2022-11-23 | [전역 변수의 무분별한 사용, 멈춰!✋](./2-1.md) |
| 2022-11-27 |  [프로토타입에 직접 접근하는 방법](./2-2.md)   |

## 얕은 복사와 깊은 복사에 대해

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는점에서 동일하다. 복사 과정은 동일하지만 **데이터 할당 과정에서 이미 차이**가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생한다.

**기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있다는 것**이다.

## new Function은 언제 사용할까?

기존에 사용하던 방법과`new Function을 사용해 함수를 만드는 방법의 가장 큰 차이는 **런타임에 받은 문자열을 사용해 함수를 만들 수 있다**는 점이다.

new Function이라는 문법을 사용하면 **어떤 문자열도 함수로 바꿀 수 있다**. 서버에서 전달받은 문자열을 이용해 새로운 함수를 만들고 이를 실행하는 것도 가능하다.

## 전역 변수의 무분별한 사용, 멈춰!✋

전역 변수의 무분별한 사용은 위험하다. 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다. 변수의 스코프는 좁을수록 좋다.

- 전역 변수의 문제점

1. 암묵적 결합 (Implicit coupling)

2. 긴 생명 주기

3. 스코프 체인 상에서 종점에 존재

4. 네임스페이스 오염

- 전역 변수의 사용을 억제하는 방법

1. 즉시 실행 함수

2. 네임스페이스 객체

3. 모듈 패턴

4. ES6 모듈

## 프로토타입에 직접 접근하는 방법

`__proto__`는 브라우저를 대상으로 개발하고 있다면 다소 구식이기 때문에 더는 사용하지 않는 것이 좋다. 대신 아래와 같은 모던한 메서드들을 사용하는 것이 좋다.

- [Object.create(proto, [descriptors])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
- [Object.getPrototypeOf(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)
- [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)

<br>
<hr>

# ◈ 김승빈
## undefinde vs null
undefined는 변수는 선언되어있지만 자료형이 결정되지 않은 변수(자스는 동적할당) <br>
null은 자료형은 객체이며 값이 비어있는 변수이다. 즉, 변수가 아무런 객체를 참조하지 않음을 명시적 표현
위 두가지의 차이로 값이 비어있다는 같은 의미를 두 가지의 타입으로 나눔


## 렉시컬 스코프(lexical Scope)
스코프는 참조 대상 식별자를 찾아내기위한 규칙이며, 자바스크립트는 이 규칙대로 식별자를 찾는다. 또 스코프는 식별자에 유효범위를 줌으로써 같은이름의 식별자가 충돌을 이르키지 않도록하고, 다른 스코프에서 같은 이름을 갖는 식별자를 만들 수 있게 해준다.
## 프로퍼티 어트리뷰트

### 📌내부 슬롯과 내부메서드
- 내부 슬롯와 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드 이다.
- 내부슬롯을 확인 할려면 직접접근할 수는 없고 간접접근은 할 수있게해주는 메서드를 사용한다.
### 📌프로퍼티 어트리뷰트가 뭘까
- 프로퍼티 어트리뷰트는 프로퍼티의 상태를 말하고 프로퍼티 상태는 프로퍼티의 값, 값의 갱신 가능여부, 열거가능여부, 재정의 가능여부를 말해준다.

### 📌데이터 프로퍼티, 접근자 프로퍼티
- 데이터프로퍼티
    - 프로퍼티 생성시 자동으로 기본값 정의
- 접근자프로퍼티
    - 다른 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로구성된 프로퍼티  

<br>
<hr>

# ◈ 김창민
| 발표 주제 |
| --- |
| 원시 타입 |
| 객 |
| TDZ |
| this |

## ◈ 원시타입 Puzzling
* 왜 0.1 + 0.2 는 0.3이 아니라 0.3000000000004 일까요?
<br>

## ◈ Answer
* 메모리에 2진수로 변환되어 저장되며, 메모리 공간이 무한히 제공되는 것이 아니기에 소수점이 무한하게 이어지는 수는 한정된 메모리 공간까지 소수점을 잘라 비슷한 숫자를 넣어준다

* 비슷한 숫자를 넣어주기에 정확히 0.1과 0.2를 넣어준 것이 아니다
<br>

## ◈ 객체 Puzzling & Answer
### (1) const로 선언된 객체는 값을 변경할 수 있다? 없다?
* 객체 자체가 상수로 선언되었을 뿐, 객체 내의 값은 재할당될 수 있다

* 이는 객체가 메모리 크기가 정해진 원시 타입이 아닌, 참조 타입이기에 가능하다. 객체 내에 메모리 주소값(address, 참조값)이 할당되어 있고, 그 주소가 바뀌는 것이 아니므로 재할당이 가능하다

<br>

### (2) Object는 모든 프로퍼티에 대해서 객체가 추가한 순서 그대로 정렬된다.[O/X]
* 정수 프로퍼티(integer property)는 자동 정렬되고, 나머지는 추가한 순서대로 정렬된다

<br>

## ◈ 일시적 사각지대(Temporal Dead Zone; TDZ)
* let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생

   * let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대(TDZ)에 빠지기 때문

### (1) 선언 단계(Declaration phase)
* 변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.

### (2) 초기화 단계(Initialization phase)
* 변수 객체(Variable Object)에 등록된 변수를 위한 공간을 메모리에 확보한다. 이 단계에서 변수는 undefined로 초기화된다.

### (3) 할당 단계(Assignment phase)
* undefined로 초기화된 변수에 실제 값을 할당한다.
<br>

## ◆ this Question
### ◈ this 사용할 때, 주의할 점
```
* this는 객체의 프로퍼티나 메서드를 참조하기 위한 변수이므로, 객체의 메서드 내부 or 생성자 함수 내부에서만 의미가 있다

* 따라서 strict mode에서 일반함수 내부의 this에는 undefined가 바인딩된다
```
<br>

### ◈ 화살표 함수에서의 this는 무엇을 의미할까?
__Ex >__
```
var value = 1;

const obj = {
  value: 100,
  foo() {
    setTimeout(() => console.log(this.value), 100);  // 0.1초 뒤 this의 value값 호출하는 함수 foo
  }
};
```

```
obj.foo();

// 100
// 화살표 함수의 this는 상위 스코프의 this를 가리키기 때문에 obj의 value는 100이
```

<br>
<hr>

# ◈ 이수호
## 동적 타이핑(Dynamic typing), 정적타이핑 (Static typing)

### 1) 동적타이핑 (Dynamic typing)

#### 정리

-코드를 작성하는 시간이 빠르다.
-코드를 실행하는 속도가 느리다.
-코드의 내용, 로직을 파악하기 쉽다.
-처음 프로그래밍을 학습하는 사람에게 적합한 언어이다.
-속도를 중요시하는 작업에선 사용하기 부적합하지만 작고 단순한 프로젝트를 하기엔 적합하다.

### 2) 정적타이핑 (Static typing)

#### 정리

-코드를 작성하는 시간이 느리다.
-코드를 실행하는 속도가 빠르다.
-코드의 구조를 파악하기 쉽다.
-처음 프로그래밍 언어를 학습하는 사람들에겐 어려울 수 있다.
-크고 복잡하며 여러 사람들이 함께 참여하는 프로젝트에 적합하다.


## 렉시컬 환경이란?

렉시컬 환경은 식별자와 식별자에 바인딩된 값.
그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.
실행 컨텍스트 스택이 코드의 실행 순서를 관리 한다면 렉시컬 환경은 스코프와 식별자를 관리 한다.

## 전역 변수의 생명 주기는

- 함수와 달리 전역 코드는 명시적 호출 없이 실행된다.
  (js 로드되자마자 곧바로 해석되고 실행된다는 말이다)
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다
- 전역 변수의 생명 주기와 전역 객체의 생명 주기가 일치한다는 것을 의미
- 즉, 웹 페이지를 닫을 때 까지 유효하다고 볼 수 있다.


## 래퍼객체

래퍼 객체란 이름처럼 원시 타입의 값을 감싸는 형태의 객체이다.
number, string, boolean, symbol 데이터 타입에 각각 대응하는 Number, String, Boolean, Symbol이 제공된다.

<br>
<hr>

# ◈ 황정현
| 발표 주제 |
| --- |
| 데이터 타입 |
| 점 표기법과 대괄호 표기법 차이 |
| TDZ |
| call과 apply |

## 데이터 타입

```jsx
var integer = 10;        // 정수
var double = 10.12;      // 실수
var negative = -20;      // 음의 정수
var binary = 0b01000001; // 2진수
var octal = 0o101;       // 8진수
var hex = 0x41;          // 16진수
```

2진수, 8진수, 16진수 리터럴은 메모리에 동일한 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 

자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

```jsx
console.log(binary); // 65
console.log(octal);  // 65
console.log(hex);    // 65
// 표기법만 다를뿐 같은 값이다.
console.log(binary === octal); // true
console.log(octal === hex);    // true
```

## 점 표기법과 대괄호 표기법 차이

```jsx
let myself = {
  name: 'Code Kim',
  country: 'South Korea',
  age: 30,
  cats: ['냥순', '냥돌']
};

let myKey = 'cats';

console.log(myself['cats']);  // ['냥순', '냥돌']
console.log(myself[myKey]);   // ['냥순', '냥돌']
// 변수 myKey 활용 가능
console.log(myself.myKey);    // undefined
// 변수 myKey 활용 불가능
```

점표기법에 비해 괄호 표기법을 사용하면, 객체 프로퍼티에 변수를 활용하여 접근이 가능하다

## ⛳ TDZ

`const` 변수 선언부터 시작해보자. 변수를 선언하고 초기화하면 변수에 접근할 수 있다. 예상한대로 동작한다.

```jsx
const white = '#FFFFFF';

white; // => '#FFFFFF'
```

이번에는 선언 전에 `white` 변수에 접근해보도록 하겠다.

```jsx
white; // throws `ReferenceError`
const white = '#FFFFFF';

white
```

`***const white = '#FFFFFF'` 구문 전 줄까지, `white` 변수는 TDZ에 있다.**

TDZ에 있는 `white` 변수에 접근하게 되면 , `ReferenceError: Cannot access 'white' before initialization` 자바스크립트 에러가 발생한다.

TDZ에 영향을 받지 않는 구문

`function, var, import`

흥미로운 점으로 `import` 모듈 역시 호이스팅 된다.

`// Works! myFunction(); import { myFunction } from './myModule';`

`import` 구문이 호이스팅 되기 때문에, 자바스크립트 파일 시작 부분에서 디펜던시 모듈을 가져오는 것이 좋다.

[TDZ을 모른 채 자바스크립트 변수를 사용하지 말라](https://ui.toast.com/weekly-pick/ko_20191014)

## call apply

arguments는 함수라면 처음부터 갖고 있는 숨겨진 속성인데요. 바로 함수에 들어온 인자를 배열 형식으로 반환합니다. (배열은 아닙니다. 유사 배열이라고 부릅니다.)

```jsx
function example() {
  console.log(arguments);
}
example(1, 'string', true); // [1, 'string', true]
```

생긴 건 배열이지만, 배열이 아니라 유사 배열이기 때문에, 배열의 메소드는 쓸 수 없습니다.

```jsx
function example2() {
  console.log(arguments.join()); // Array.prototype.join() 메소드는 사용할 수 없다.
}
example2(1, 'string', true); // Uncaught TypeError: arguments.join is not a function
```

에러가 발생하죠? arguments는 모양만 배열이지 실제 배열이 아니라서 배열의 메소드를 쓰면 에러가 발생합니다.

이 때 바로 call이나 apply가 효력을 발휘합니다.

```jsx
function example3() {
  console.log(Array.prototype.join.call(arguments));
}
example3(1, 'string', true); // '1,string,true'
```

배열의 프로토타입에 있는 join 함수를 빌려 쓰는겁니다. this는 arguments를 가리키게 하고요.

1. join() 으로 배열을 문자열로 반환하려고 합니다.
2. 함수 인자로 값들을 넘깁니다. arguments로 배열형태로 받겠지만, 유사배열이라 arguments.join()같은 게 될리가 없죠.
3. 그래서 우선은 프로토타입 메서드 Array.prototype.join()을 불러오고 그 뒤에 .call()로 join함수를 조작합니다.
4. callI(arguments)로 this를 유사배열로 가리키게 합니다. 본래는 Array객체를 가리키고 있지만 바꾼 것이죠. 그러면 Array.prototype.join()이 최종적으로 [1, 'string', true].join() 이 되게 됩니다.

join 외에도 slice, concat 등등 모든 메소드를 이 방식으로 사용할 수 있습니다.
